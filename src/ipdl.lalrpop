// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

use ast::{Compress, CxxTypeKind, Direction, IncludeType, MessageDecl,
          MessageModifier, Node, Namespace, Nesting, NamespacedNode,
          ParserState, Param, Priority, Protocol, QualifiedId, SendSemantics,
          StructField, TypeSpec};

grammar(parser_state: &ParserState);

//-----------------------------------------------------------------------------

ID: String = <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => String::from(s);

STRING: String = <s:r#""[^"\n]*""#> => String::from(s);


//-----------------------------------------------------------------------------

pub TranslationUnit: (Vec<Node>, Vec<Vec<(Namespace, NamespacedNode)>>)  = {
    <p:Preamble> <ns:NamespaceThing+> => (p, ns)
};


//--------------------
// Preamble
pub Preamble: Vec<Node> = {
    (PreambleStmt ";")* => {
        let mut v = Vec::new();
        for (p, _) in <> {
            v.push(p);
        }
        v
    }
};

pub PreambleStmt = { CxxIncludeStmt, IncludeStmt, UsingStmt };

pub CxxIncludeStmt: Node = {
  "include" <file:STRING> => Node::CxxInclude(file),
};

pub IncludeStmt: Node = {
    "include" "protocol" <id:ID> => Node::Include(IncludeType::Protocol, id) /* resolveIncludePath etc. */,
    "include" <id:ID> => Node::Include(IncludeType::Header, id),
};

pub UsingStmt: Node = {
    "using" <t:CxxType> "from" <h:STRING> => Node::Using { cxx_type: t, header: h, kind: None },
    "using" <k:CxxTypeKind> <t:CxxType> "from" <h:STRING> => Node::Using { cxx_type: t, header: h, kind: Some(k) },
};

pub CxxTypeKind: CxxTypeKind = {
    "class" => CxxTypeKind::Class,
    "struct" => CxxTypeKind::Struct
};


//--------------------
// Namespaced stuff

NamespaceThing: Vec<(Namespace, NamespacedNode)> = {
    "namespace" <name:ID> "{" <many_things:NamespaceThing+> "}" => {
        let mut things = Vec::new();
        for old_things in many_things {
            for (mut ns, node) in old_things {
                ns.add_outer_namespace(&name);
                things.push((ns, node))
            }
        }
        things
    },
    <s:StructDecl> => vec![(s.0, NamespacedNode::Struct(s.1))],
    <u:UnionDecl> => vec![(u.0, NamespacedNode::Union(u.1))],
    <p:ProtocolDefn> => vec![(p.0, NamespacedNode::Protocol(p.1))],
};

StructDecl: (Namespace, Vec<StructField>) = {
    "struct" <name:ID> "{" <raw_fields: (StructField ";")* > => {
        let mut fields = Vec::new();
        for (f, _) in raw_fields {
            fields.push(f);
        }
        (Namespace::new(name), fields)
    }
};

StructField: StructField = {
    <t:Type> <field_name:ID> => StructField::new(t, field_name)
};

UnionDecl: (Namespace, Vec<TypeSpec>) = {
    "union" <name:ID> "{" <raw_components: (Type ";")+ > => {
        let mut components = Vec::new();
        for (c, _) in raw_components {
            components.push(c);
        }
        (Namespace::new(name), components)
    }
};

ProtocolDefn: (Namespace, Protocol) = {
    <q:ProtocolSendSemanticsQual?> "protocol" <name:ID> "{"
        <managers:ManagersStmt*> <manages:ManagesStmt*> <decls:MessageDeclThing*> "}" =>
    {
        // XXX If we're currently parsing a header, produce an error.
        let (nesting, send_semantics) = q.unwrap_or((Nesting::None, SendSemantics::Async));
        (Namespace::new(name), Protocol::new(send_semantics, nesting, managers, manages, decls))
    },
};


//--------------------
// manager/manages stmts

ManagersStmt: Vec<String> = {
    "manager" <l:ManagerList> ";" => l
};

ManagerList: Vec<String> = {
    <name:ID> => vec![name],
    <l:ManagerList> "or" <name:ID> => {
        let mut l = l;
        l.push(name);
        l
    }
};

ManagesStmt: String = {
    "manages" <name:ID> ";" => name
};


//--------------------
// Message decls

MessageDeclThing : MessageDecl = {
    MessageDirectionLabel ":" <m:MessageDecl> ";" => m,
    <m:MessageDecl> ";" => m,
};

MessageDirectionLabel : () = {
    "parent" => parser_state.direction.set(Some(Direction::In)),
    "child" => parser_state.direction.set(Some(Direction::Out)),
    "both" => parser_state.direction.set(Some(Direction::InOut)),
};

MessageDecl: MessageDecl = {
    <qual:SendSemanticsQual> <msg:MessageBody> => {
        let mut msg = msg;
        msg.nesting = qual.0;
        msg.prio = qual.1;
        msg.send_semantics = qual.2;

        // XXX Why isn't direction set in MessageBody? Then it might
        // not need to be an Option.
        if parser_state.direction.get().is_none() {
            // XXX Surely there's a better way to do this.
            panic!("Missing message direction.");
        }
        msg.direction = parser_state.direction.get().clone();

        msg
    },
};

MessageBody: MessageDecl = {
    <name:MessageId> "(" <in_params:ParamList> ")" <out_params:MessageOutParams> <modifiers:MessageModifier*> => {
        let mut decl = MessageDecl::new(name);
        decl.add_in_params(in_params);
        decl.add_out_params(out_params);
        decl.add_modifiers(modifiers);
        decl
    },
};

MessageId: String = {
    <id:ID> => id,
    // The Python IPDL parser has a separate case for ID and the
    // keyword "delete". It produces an error if the ID is
    // "delete". However, I think the error is impossible, because the
    // rule for ID will capitalize the string "delete". I don't think
    // a separate case for the keyword delete is needed, and I don't
    // know how they would even be distinguished.
    "__delete__" => String::from("__delete__"),
    // The Python IPDL parser has a case for "~" ID, but it just
    // produces an obsolescence error. The error message dates back to
    // at least 2010, so I don't think it is needed any more.
};

MessageOutParams: Vec<Param> = {
    "returns" "(" <l:ParamList> ")" => l,
    => Vec::new(),
};

MessageModifier: MessageModifier = {
    "verify" => MessageModifier::Verify,
    "compress" => MessageModifier::Compress(Compress::Enabled),
    "compressall" => MessageModifier::Compress(Compress::All),
};


//--------------------
// State machine

// XXX This should be removed.
State = { ID };


//--------------------
// Minor stuff

Nesting: Nesting = {
    "not" => Nesting::None,
    "inside_sync" => Nesting::InsideSync,
    "inside_cpow" => Nesting::InsideCpow,
};

Priority: Priority = {
    "normal" => Priority::Normal,
    "high" => Priority::High,
};

SendQualifier: (Option<Nesting>, Option<Priority>) = {
    "nested" "(" <n:Nesting> ")" => (Some(n), None),
    "prio" "(" <p:Priority> ")" => (None, Some(p)),
};

SendQualifierList: (Option<Nesting>, Option<Priority>) = {
    <q:SendQualifier> <l:SendQualifierList> => (l.0.or(q.0), l.1.or(q.1)),
    => (None, None)
};

SendSemanticsQual: (Nesting, Priority, SendSemantics) = {
    <l:SendQualifierList> "async" =>
        (l.0.unwrap_or(Nesting::None),
         l.1.unwrap_or(Priority::Normal),
         SendSemantics::Async),
    <l:SendQualifierList> "sync" =>
        (l.0.unwrap_or(Nesting::None),
         l.1.unwrap_or(Priority::Normal),
         SendSemantics::Sync),
    "intr" => (Nesting::None, Priority::Normal, SendSemantics::Intr)
};

ProtocolSendSemanticsQual: (Nesting, SendSemantics) = {
    "async" => (Nesting::None, SendSemantics::Async),
    "sync" => (Nesting::None, SendSemantics::Sync),
    "nested" "(" "upto" <n:Nesting> ")" "async" => (n, SendSemantics::Async),
    "nested" "(" "upto" <n:Nesting> ")" "sync" => (n, SendSemantics::Async),
    "intr" => (Nesting::None, SendSemantics::Intr),
};

ParamList: Vec<Param> = {
    <l:ParamList> "," <p:Param> => {
        let mut l = l;
        l.push(p);
        l
    },
    <p:Param> => vec![p],
    => Vec::new()
};

Param: Param = {
    <t:Type> <name:ID> => Param::new(t, name)
};

Type: TypeSpec = {
    // only actor types are nullable; we check this in the type checker
    <is_nullable: "nullable"?> <t:BasicType> => t.set_nullable(is_nullable.is_some())
};

BasicType: TypeSpec = {
    ScalarType,
    <t:ScalarType> "[" "]" => t.set_array(true)
};

ScalarType: TypeSpec = {
    ActorType,
    <id:CxxID> => {
        // ID == CxxType; we forbid qnames here,
        // in favor of the |using| declaration
        TypeSpec::new(QualifiedId::new(id))
    }
};

// XXX This is probably state machine related, and so should be removed.
ActorType: TypeSpec = {
    <id:ID> ":" <st:State> => TypeSpec::new(QualifiedId::new(id)).add_state(st)
};


//--------------------
// C++ stuff

CxxType: TypeSpec = {
    <id:QualifiedID> => TypeSpec::new(id),
    <id:CxxID> => TypeSpec::new(QualifiedId::new(id)),
};

QualifiedID: QualifiedId = {
    <qual_id:QualifiedID> "::" <id:CxxID> => qual_id.qualify(id),
    <id1:CxxID> "::" <id2:CxxID> => QualifiedId::new(id1).qualify(id2),
};

CxxID: String = {
    ID,
    CxxTemplateInst,
};

CxxTemplateInst: String = {
    <t_name:ID> "<" <arg:ID> ">" => t_name + "<" + &arg + ">"
};
