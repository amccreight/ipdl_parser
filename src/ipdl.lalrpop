use ast::{CxxTypeKind, IncludeType, MessageModifier, Node, Namespace,
          NamespacedNode, Param, QualifiedId, StructField, TypeSpec};

grammar;

//-----------------------------------------------------------------------------

ID: String = <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => String::from(s);

STRING: String = <s:r#""[^"\n]*""#> => String::from(s);


//--------------------
// Preamble
pub Preamble = { (PreambleStmt ";")* };

pub PreambleStmt = { CxxIncludeStmt, IncludeStmt, UsingStmt };

pub CxxIncludeStmt: Node = {
  "include" <file:STRING> => Node::CxxInclude(file),
};

pub IncludeStmt: Node = {
    "include" "protocol" <id:ID> => Node::Include(IncludeType::Protocol, id) /* resolveIncludePath etc. */,
    "include" <id:ID> => Node::Include(IncludeType::Header, id),
};

pub UsingStmt: Node = {
    "using" <t:CxxType> "from" <h:STRING> => Node::Using { cxx_type: t, header: h, kind: None },
    "using" "class" <t:CxxType> "from" <h:STRING> => Node::Using { cxx_type: t, header: h, kind: Some(CxxTypeKind::Class) },
    "using" "struct" <t:CxxType> "from" <h:STRING> => Node::Using { cxx_type: t, header: h, kind: Some(CxxTypeKind::Struct) },
};


//--------------------
// Namespaced stuff

// NamespacedStuff is just NamespaceThing.

NamespaceThing: Vec<(Namespace, NamespacedNode)> = {
    "namespace" <name:ID> "{" <many_things:NamespaceThing+> "}" => {
        let mut things = Vec::new();
        for old_things in many_things {
            for (mut ns, node) in old_things {
                ns.add_outer_namespace(&name);
                things.push((ns, node))
            }
        }
        things
    },
    <s:StructDecl> => {
        let mut v = Vec::new();
        v.push(s);
        v
    },
    <u:UnionDecl> => {
        let mut v = Vec::new();
        v.push(u);
        v
    },
    // XXX <p:ProtocolDefn> => ...
};

StructDecl: (Namespace, NamespacedNode) = {
    "struct" <name:ID> "{" <raw_fields: (StructField ";")* > => {
        let mut fields = Vec::new();
        for (f, _) in raw_fields {
            fields.push(f);
        }
        (Namespace::new(name), NamespacedNode::StructDecl(fields))
    }
};

StructField: StructField = {
    <t:Type> <field_name:ID> => StructField::new(t, field_name)
};

UnionDecl: (Namespace, NamespacedNode) = {
    "union" <name:ID> "{" <raw_components: (Type ";")+ > => {
        let mut components = Vec::new();
        for (c, _) in raw_components {
            components.push(c);
        }
        (Namespace::new(name), NamespacedNode::UnionDecl(components))
    }
};

// XXX ProtocolDefn

// XXX ProtocolBody


//--------------------
// spawns/bridges/opens stmts

// XXX SpawnsStmtsOpt

// XXX SpawnsStmt

// XXX AsOpt

// XXX BridgesStmtsOpt

// XXX BridgesStmt

// XXX OpensStmtsOpt

// XXX OpensStmt


//--------------------
// manager/manages stmts

// XXX ManagersStmtOpt

// XXX ManagersStmt

// XXX ManagerList

// XXX ManagesStmtsOpt

// XXX ManagesStmt


//--------------------
// Message decls

// XXX MessageDeclsOpt

// XXX MessageDeclThing

// XXX MessageDirectionLabel

// XXX MessageDecl

// XXX MessageBody

// XXX MessageId

// XXX MessageInParams

// XXX MessageOutParams

// XXX OptionalMessageModifiers

MessageModifier: MessageModifier = {
    "verify" => MessageModifier::Verify,
    "compress" => MessageModifier::Compress,
    "compressall" => MessageModifier::CompressAll,
};


//--------------------
// State machine

State = { ID };


//--------------------
// Minor stuff

ParamList: Vec<Param> = {
    <l:ParamList> "," <p:Param> => {
        let mut l = l;
        l.push(p);
        l
    },
    <p:Param> => {
        let mut l = Vec::new();
        l.push(p);
        l
    } ,
    => Vec::new()
};

Param: Param = {
    <t:Type> <name:ID> => Param::new(t, name)
};

Type: TypeSpec = {
    // only actor types are nullable; we check this in the type checker
    <is_nullable: "nullable"?> <t:BasicType> => t.set_nullable(is_nullable.is_some())
};

BasicType: TypeSpec = {
    ScalarType,
    <t:ScalarType> "[" "]" => t.set_array(true)
};

ScalarType: TypeSpec = {
    ActorType,
    <id:CxxID> => {
        // ID == CxxType; we forbid qnames here,
        // in favor of the |using| declaration
        TypeSpec::new(QualifiedId::new(id))
    }
};

ActorType: TypeSpec = {
    <id:ID> ":" <st:State> => TypeSpec::new(QualifiedId::new(id)).add_state(st)
};


//--------------------
// C++ stuff

CxxType: TypeSpec = {
    <id:QualifiedID> => TypeSpec::new(id),
    <id:CxxID> => TypeSpec::new(QualifiedId::new(id)),
};

QualifiedID: QualifiedId = {
    <qual_id:QualifiedID> "::" <id:CxxID> => qual_id.qualify(id),
    <id1:CxxID> "::" <id2:CxxID> => QualifiedId::new(id1).qualify(id2),
};

CxxID: String = {
    ID,
    CxxTemplateInst,
};

CxxTemplateInst: String = {
    <t_name:ID> "<" <arg:ID> ">" => t_name + "<" + &arg + ">"
};
